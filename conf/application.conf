# This is the main configuration file for the application.
# https://www.playframework.com/documentation/latest/ConfigFile

# Include the secure configuration file with all the sensitive information (this file is never shared or placed in the git repository)
include "secure"

# Database configuration (the password is in the secure file)
db {
	default {
		driver = com.mysql.jdbc.Driver
		url = "jdbc:mysql://localhost/remote_logging_app_db?characterEncoding=UTF-8&useSSL=false"
		username = remote_logging_app
		logSql = true
	}
}

# Ebeans configuration
ebean {
	default = ["models.db.*"]
}

# Akka Configuration
akka {
    default-dispatcher {
        fork-join-executor {
            pool-size-max=64
        }
    }

    actor {
        debug {
            receive=on
        }
    }
}

play {

	http {
	 	session {
			# The cookie name
	 		cookieName = "remote_logging_app_session"

			# Whether the secure attribute of the cookie should be set to true
			# (this should be set to true in Production)
	 		secure = false

			# The max age to set on the cookie.
			# If null, the cookie expires when the user closes their browser.
			# An important thing to note, this only sets when the browser will discard the cookie.
			maxAge = 1 hour

			# Whether the HTTP only attribute of the cookie should be set to true
			httpOnly = false

			# The value of the SameSite attribute of the cookie. Set to null for no SameSite attribute.
			# Possible values are "lax" and "strict". If misconfigured it's set to null.
			sameSite = "none"

			# The domain to set on the session cookie
			# If null, does not set a domain on the session cookie.
			domain = null

			# The session path
			# Must start with /.
			path = ${play.http.context}

			jwt {
				# The JWT signature algorithm to use on the session cookie
				# uses 'alg' https://tools.ietf.org/html/rfc7515#section-4.1.1
				signatureAlgorithm = "HS256"

				# The time after which the session is automatically invalidated.
				# Use 'exp' https://tools.ietf.org/html/rfc7519#section-4.1.4
				expiresAfter = ${play.http.session.maxAge}

				# The amount of clock skew to accept between servers when performing date checks
				# If you have NTP or roughtime synchronizing between servers, you can enhance
				# security by tightening this value.
				clockSkew = 5 minutes

				# The claim key under which all user data is stored in the JWT.
				dataClaim = "data"
			}
	 	}

	 	errorHandler = managers.ErrorManager
	}

	evolutions {
		enabled = true
		autocommit = false
		useLocks = false
		autoApply = false
		autoApplyDowns = false
	}

	i18n {
		langs = [ "pt", "en" ]
	}

	modules {
		enabled += managers.OnStartupModule
	}

	mailer {
        # (mandatory)
  		host = "example.com"
        # (defaults to 25)
  		port = 25
        # (defaults to no)
  		ssl = no
        # (defaults to no)
  		tls = no
        # (defaults to no)
  		tlsRequired = no
        # (optional)
  		user = null
        # (optional)
  		password = null
        # (defaults to no, to take effect you also need to set the log level to "DEBUG" for the application logger)
  		debug = no
        # (defaults to 60s in milliseconds)
  		timeout = null
        # (defaults to 60s in milliseconds)
  		connectiontimeout = null
        # (defaults to no, will only log all the email properties instead of sending an email)
  		mock = no

  		props {
    		# Additional SMTP properties used by JavaMail. Can override existing configuration keys from above.
    		# A given property will be set for both the "mail.smtp.*" and the "mail.smtps.*" prefix.
    		# For a list of properties see:
    		# https://javaee.github.io/javamail/docs/api/com/sun/mail/smtp/package-summary.html#properties

    		# Example:
    		# To set the local host name used in the SMTP HELO or EHLO command:
    		# localhost = 127.0.0.1
    		# Results in "mail.smtp.localhost=127.0.0.1" and "mail.smtps.localhost=127.0.0.1" in the JavaMail session.
  		}
	}

	filters {
		# Enabling the GZip filter
		enabled += play.filters.gzip.GzipFilter

		# Enabling the CORS Filter
		# See: https://www.playframework.com/documentation/2.7.x/CorsFilter
		enabled += play.filters.cors.CORSFilter

        # Custom filter to enable the logging of request times (includes a Request-Time that is added to all requests)
        enabled += filters.RequestTimeLoggingFilter

        # Custom filter to enable maintenance lock (set in application's runtime configuration)
        enabled += filters.MaintenanceLockFilter

		# CSRF config (CSRF filter is enabled by default - play.filters.csrf.CSRFFilter)
  		csrf {

    		# Token configuration
    		token {
      			# The token name
      			name = "csrfToken"

      			# Whether tokens should be signed or not
      			sign = true
    		}

    		# Cookie configuration
    		cookie {
      			# If non null, the CSRF token will be placed in a cookie with this name
      			name = null

      			# Whether the cookie should be set to secure
      			secure = ${play.http.session.secure}

      			# Whether the cookie should have the HTTP only flag set
      			httpOnly = false

      			# The value of the SameSite attribute of the cookie. Set to null for no SameSite attribute.
      			# Possible values are "lax" and "strict". If misconfigured it's set to null.
      			sameSite = ${play.http.session.sameSite}
    		}

    		# How much of the body should be buffered when looking for the token in the request body
    		body.bufferSize = ${play.http.parser.maxMemoryBuffer}

    		# Bypass the CSRF check if this origin is trusted by the CORS filter
    		bypassCorsTrustedOrigins = true

    		# Header configuration
    		header {

      			# The name of the header to accept CSRF tokens from.
      			name = "Csrf-Token"


			    # Defines headers that must be present to perform the CSRF check. If any of these headers are present, the CSRF
			    # check will be performed.
			    #
			    # By default, we only perform the CSRF check if there are Cookies or an Authorization header.
			    # Generally, CSRF attacks use a user's browser to execute requests on the client's behalf. If the user does not
			    # have an active session, there is no danger of this happening.
			    #
			    # Setting this to null or an empty object will protect all requests.
			    protectHeaders {
			      	Cookie = "*"
			      	Authorization = "*"
			    }

			    # Defines headers that can be used to bypass the CSRF check if any are present. A value of "*" simply
			    # checks for the presence of the header. A string value checks for a match on that string.
			    bypassHeaders {}
			  }

    		# Method lists
    		method {
      			# If non empty, then requests will be checked if the method is not in this list.
      			whiteList = ["GET", "HEAD", "OPTIONS"]

      			# The black list is only used if the white list is empty.
      			# Only check methods in this list.
      			blackList = []
    		}

    		# Content type lists
    		# If both white lists and black lists are empty, then all content types are checked.
    		contentType {
      			# If non empty, then requests will be checked if the content type is not in this list.
      			whiteList = []

			    # The black list is only used if the white list is empty.
			    # Only check content types in this list.
			    blackList = []
    		}

    		routeModifiers {
		    	# If non empty, then requests will be checked if the route does not have this modifier. This is how we enable the
		      	# nocsrf modifier, but you may choose to use a different modifier (such as "api") if you plan to check the
		      	# modifier in your code for other purposes.
		      	whiteList = ["nocsrf"]

      			# If non empty, then requests will be checked if the route contains this modifier
      			# The black list is used only if the white list is empty
      			blackList = []
    		}

    		# The error handler.
    		# Used by Play's built in DI support to locate and bind a request handler.  Must be one of the following:
    		# - A FQCN that implements play.filters.csrf.CSRF.ErrorHandler (Scala).
    		# - A FQCN that implements play.filters.csrf.CSRFErrorHandler (Java).
    		# - provided, indicates that the application has bound an instance of play.filters.csrf.CSRF.ErrorHandler through some
    		#   other mechanism.
    		# If null, will attempt to load a class called CSRFErrorHandler in the root package, otherwise if that's
    		# not found, will default to play.filters.csrf.CSRF.CSRFHttpErrorHandler, which delegates to the configured
    		# HttpRequestHandler.
    		errorHandler = null
  		}

  		# Security headers filter configuration (Security Headers filter is enabled by default - play.filters.headers.SecurityHeadersFilter)
  		headers {

    		# The X-Frame-Options header. If null, the header is not set.
    		frameOptions = "DENY"

    		# The X-XSS-Protection header. If null, the header is not set.
    		xssProtection = "1; mode=block"

    		# The X-Content-Type-Options header. If null, the header is not set.
    		contentTypeOptions = "nosniff"

    		# The X-Permitted-Cross-Domain-Policies header. If null, the header is not set.
    		permittedCrossDomainPolicies = "master-only"

    		# The Referrer-Policy header. If null, the header is not set.
    		referrerPolicy = "origin-when-cross-origin, strict-origin-when-cross-origin"

    		# If true, allow an action to use .withHeaders to replace one or more of the above headers
    		allowActionSpecificHeaders = false
  		}

  		# Content Security Policy filter configuration (related to security-headers filter)
  		# Please see https://playframework.com/documentation/latest/CspFilter for more details.
  		csp {
    		# If true, the CSP output uses Content-Security-Policy-Report-Only header instead.
    		reportOnly = false

    		routeModifiers {
      			# If non empty, then requests will be checked if the route does not have this modifier.
      			whiteList = ["nocsp"]

      			# If non empty, then requests will be checked if the route contains this modifier
      			# The black list is used only if the white list is empty
      			blackList = []
    		}

    		# #csp-nonce
    		# Specify a nonce to be used in CSP security header
    		# https://www.w3.org/TR/CSP3/#security-nonces
    		#
    		# Nonces are used in script and style elements to protect against XSS attacks.
    		nonce {
      			# Use nonce value (generated and passed in through request attribute)
      			enabled = true

      			# Pattern to use to replace with nonce
      			pattern = "%CSP_NONCE_PATTERN%"

      			# Add the nonce to "X-Content-Security-Policy-Nonce" header.  This is useful for debugging.
      			header = false
    		}
    		# #csp-nonce

    		# Specify hashes that are used internally in the content security policy.
    		# The format of these hashes are as follows:
    		#
    		# {
    		#   algorithm = sha256
    		#   hash = "RpniQm4B6bHP0cNtv7w1p6pVcgpm5B/eu1DNEYyMFXc="
    		#   pattern = "%CSP_MYSCRIPT_HASH%"
    		# }
    		#
    		# and should be used inline the same way as the nonce pattern, i.e.
    		#
    		# script-src = "%CSP_MYSCRIPT_HASH% 'strict-dynamic' ..."
    		hashes = []

    		# #csp-directives
    		# The directives here are set to the Google Strict CSP policy by default
    		# https://csp.withgoogle.com/docs/strict-csp.html
    		directives {
      			# base-uri defaults to 'none' according to https://csp.withgoogle.com/docs/strict-csp.html
      			# https://www.w3.org/TR/CSP3/#directive-base-uri
      			base-uri = "'none'"

      			# object-src defaults to 'none' according to https://csp.withgoogle.com/docs/strict-csp.html
      			# https://www.w3.org/TR/CSP3/#directive-object-src
      			object-src = "'none'"

      			# script-src defaults according to https://csp.withgoogle.com/docs/strict-csp.html
      			# https://www.w3.org/TR/CSP3/#directive-script-src
      			script-src = ${play.filters.csp.nonce.pattern} "'unsafe-inline' 'unsafe-eval' 'strict-dynamic' https: http:"
    		}
    		# #csp-directives
  		}

  		# Allowed hosts filter configuration (Allowed hosts filter is enabled by default - play.filters.hosts.AllowedHostsFilter)
  		hosts {

    		# A list of valid hosts (e.g. "example.com") or suffixes of valid hosts (e.g. ".example.com")
    		# Note that ".example.com" will match example.com and any subdomain of example.com, with or without a trailing dot.
    		# "." matches all domains, and "" matches an empty or nonexistent host.
    		allowed = ["localhost", "127.0.0.1"]

    		routeModifiers {
      			# If non empty, then requests will be checked if the route does not have this modifier. This is how we enable the
      			# anyhost modifier, but you may choose to use a different modifier (such as "api") if you plan to check the
      			# modifier in your code for other purposes.
      			whiteList = ["anyhost"]

      			# If non empty, then requests will be checked if the route contains this modifier
      			# The black list is used only if the white list is empty
      			blackList = []
    		}
  		}

  		# GZip filter configuration
  		gzip {

    		# The buffer size to use for gzipped bytes
    		bufferSize = 8k

    		# The maximum amount of content to buffer for gzipping in order to calculate the content length before falling back
    		# to chunked encoding.
    		chunkedThreshold = 100k

    		contentType {

        		# If non empty, then a response will only be compressed if its content type is in this list.
        		# example: whiteList = [ "text/*", "application/javascript", "application/json" ]
        		whiteList = []

        		# The black list is only used if the white list is empty.
        		# Compress all responses except the ones whose content type is in this list.
        		blackList = []
    		}

    		# The compression level to use, integer, -1 to 9, inclusive. See java.util.zip.Deflater.
    		compressionLevel = -1
  		}

  		# CORS filter configuration
  		cors {

    		# The path prefixes to filter.
    		pathPrefixes = ["/"]

    		# The allowed origins. If null, all origins are allowed.
    		allowedOrigins = null

    		# The allowed HTTP methods. If null, all methods are allowed
    		allowedHttpMethods = null

    		# The allowed HTTP headers. If null, all headers are allowed.
    		allowedHttpHeaders = null

    		# The exposed headers
    		exposedHeaders = []

    		# Whether to support credentials
    		supportsCredentials = true

    		# The maximum amount of time the CORS meta data should be cached by the client
    		preflightMaxAge = 1 hour

    		# Whether to serve forbidden origins as non-CORS requests
    		serveForbiddenOrigins = false
  		}
	}
}

custom {
  office365 {
    oauth {
      base_url = "https://login.microsoftonline.com/"
      # If this oauth account only accepts accounts in a single tenant, then tenant_id must be specified here.
      # If the oauth account is multi-tenant, then tenant_id should be equal to "common"
      tenant_id = "6230e860-bfc5-4095-a6bc-104721add6e6"
      authorize_url_suffix = "/oauth2/v2.0/authorize"
      token_url_suffix = "/oauth2/token"
      client_id = "f3afba93-d35d-4f41-8f28-91e34fa1cd75"
      response_type = "code id_token"
      response_mode = "form_post"
      scope = "openid profile user.read"
      api_url = "https://graph.microsoft.com/v1.0"
    }
  }
}
